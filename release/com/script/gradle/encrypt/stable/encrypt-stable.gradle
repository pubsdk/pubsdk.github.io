import javax.crypto.Cipher
import javax.crypto.CipherInputStream
import javax.crypto.CipherOutputStream
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths
import java.security.MessageDigest
import java.security.SecureRandom
import java.util.concurrent.TimeUnit
import java.util.zip.ZipEntry
import java.util.zip.ZipFile

/**
 * 首字母转大写
 * @param s
 * @return
 */
def toUpperCaseFirstOne(String s) {
    if (s == null) {
        return null
    }
    if (Character.isUpperCase(s.charAt(0))) {
        return s;
    }
    return (new StringBuilder()).append(Character.toUpperCase(s.charAt(0))).append(s.substring(1)).toString();
}

class Global {
    static def sEncryptFileList = new LinkedHashSet<String>()
}

def checkMavenUrl(urlString) {
    if (urlString == null) {
        return false
    }
    try {
        URL url = new URL(urlString)
        HttpURLConnection urlConnection = url.openConnection()
        urlConnection.connect()
        int httpCode = urlConnection.getResponseCode()
        urlConnection.disconnect()
        return httpCode == HttpURLConnection.HTTP_OK
    } catch (Exception e) {
    }
    return false
}

def mavenUrls = [
        "https://repo1.maven.org/maven2",
        "https://dl.google.com/dl/android/maven2",
        "https://dl-maven-android.mintegral.com/repository/mbridge_android_sdk_oversea",
        "https://cboost.jfrog.io/artifactory/chartboost-ads/",
        "https://cboost.jfrog.io/artifactory/chartboost-mediation",
        "https://jfrog.anythinktech.com/artifactory/overseas_sdk",
        "https://artifactory.bidmachine.io/bidmachine",
        "https://verve.jfrog.io/artifactory/verve-gradle-release",
        "https://android-sdk.is.com/",
        "https://artifact.bytedance.com/repository/pangle",
        "https://artifacts.applovin.com/android",
        "https://artifactory.verizonmedia.com/artifactory/maven",
]
try {
    def sdkMavenUrls = ext.has("mavenUrls") ? ext["mavenUrls"] : mavenUrls
    project.rootProject.allprojects.repositories.each {
        repo ->
            for (String url : sdkMavenUrls) {
                repo.maven { r -> r.url = url }
            }
    }
} catch (Exception e) {
    println("add maven error : " + e)
}

project.afterEvaluate {
    if (project.android.productFlavors.size() > 0) {// 如果有产品风味
        project.android.productFlavors.each { flavor ->
            def productFlavor = toUpperCaseFirstOne(flavor.name)
            def rTask = project.tasks.findByName(String.format("package%sRelease", productFlavor))
            if (rTask != null) {
                rTask.doFirst {
                    encryptAssetsFiles(flavor.name)
                }
            }

            rTask = project.tasks.findByName(String.format("merge%sReleaseAssets", productFlavor))
            if (rTask != null) {
                rTask.doLast {
                    encryptAssetsFiles(flavor.name)
                }
            }

            def packageReleaseBundle = project.tasks.findByName(String.format("package%sReleaseBundle", productFlavor))
            if (packageReleaseBundle != null) {
                packageReleaseBundle.doFirst {
                    removeSpecialProguard(flavor.name)
                }
            }

            def signReleaseBungleTask = project.tasks.findByName(String.format("sign%sReleaseBundle", productFlavor))
            if (signReleaseBungleTask != null) {
                signReleaseBungleTask.doLast {
                    removeBundleMetaData(flavor.name)
                    listBundleMetaDataFiles(flavor.name)
                }
            }

            String assembleTaskName = String.format("assemble%sRelease", productFlavor)
            def aTask = project.tasks.findByName(assembleTaskName);
            if (aTask != null) {
                aTask.doLast {
                    openReleaseDir(flavor.name)
                }
            }
            String generateAdFile = String.format("generateAdFile%s", productFlavor)
            def adFileGenerateTask = project.tasks.create(generateAdFile, {
                doLast {
                    adFileGenerateByUser(flavor.name)
                }
            })
            adFileGenerateTask.setGroup("mobsdk")

            String firebaseDebugView = String.format("firebaseDebugView%s", productFlavor)
            def firebaseDebugViewTask = project.tasks.create(firebaseDebugView, {
                doLast {
                    firebaseDebugViewByUser(flavor.name)
                }
            })
            firebaseDebugViewTask.setGroup("mobsdk")
        }
    } else { // 无产品风味
        def rTask = project.tasks.findByName("packageRelease")
        if (rTask != null) {
            rTask.doFirst {
                encryptAssetsFiles(null)
            }
        }

        rTask = project.tasks.findByName("mergeReleaseAssets")
        if (rTask != null) {
            rTask.doLast {
                encryptAssetsFiles(null)
            }
        }

        def packageReleaseBundle = project.tasks.findByName("packageReleaseBundle")
        if (packageReleaseBundle != null) {
            packageReleaseBundle.doFirst {
                removeSpecialProguard(null)
            }
        }

        def signReleaseBundle = project.tasks.findByName("signReleaseBundle")
        if (signReleaseBundle != null) {
            signReleaseBundle.doLast {
                removeBundleMetaData(null)
                listBundleMetaDataFiles(null)
            }
        }

        def aTask = project.tasks.findByName("assembleRelease");
        if (aTask != null) {
            aTask.doLast {
                openReleaseDir(null)
            }
        }

        def adFileGenerateTask = project.tasks.create("generateAdFile", {
            doLast {
                adFileGenerateByUser(null)
            }
        })
        adFileGenerateTask.setGroup("mobsdk")

        String firebaseDebugView = String.format("firebaseDebugView")
        def firebaseDebugViewTask = project.tasks.create(firebaseDebugView, {
            doLast {
                firebaseDebugViewByUser(null)
            }
        })
        firebaseDebugViewTask.setGroup("mobsdk")
    }


    def addDebugFileTask = project.tasks.create("addDebugFile", {
        doLast {
            addDebugFile()
        }
    })
    addDebugFileTask.setGroup("mobsdk")

    def delDebugFileTask = project.tasks.create("deleteDebugFile", {
        doLast {
            delDebugFile()
        }
    })
    delDebugFileTask.setGroup("mobsdk")

    String aab2apkTaskName = String.format("aab2abk")
    def aab2apkTask = project.tasks.create(aab2apkTaskName, {
        doLast {
            transformAab2ApkFlavor()
        }
    })
    aab2apkTask.setGroup("mobsdk")

    String taskName = String.format("newEncryptString")
    def taskObject = project.tasks.create(taskName, {
        doLast {
            newEncryptStringTask()
        }
    })
    taskObject.setGroup("mobsdk")

    taskName = String.format("newDecryptString")
    taskObject = project.tasks.create(taskName, {
        doLast {
            newDecryptStringTask()
        }
    })
    taskObject.setGroup("mobsdk")

    taskName = String.format("oldEncryptString")
    taskObject = project.tasks.create(taskName, {
        doLast {
            oldEncryptStringTask()
        }
    })
    taskObject.setGroup("mobsdk")

    taskName = String.format("oldDecryptString")
    taskObject = project.tasks.create(taskName, {
        doLast {
            oldDecryptStringTask()
        }
    })
    taskObject.setGroup("mobsdk")
}

def firebaseDebugViewByUser(flavor) {
    def applicationId = getApplicationId(flavor)
    def cmdString = "adb shell setprop debug.firebase.analytics.app " + applicationId
    println "firebase debug view cmdstr : [" + cmdString + "]"
    cmdString.execute().text.trim()
    println "firebase debug view result : success"
}

def addDebugFile() {
    def cmdString = "adb shell touch /sdcard/Download/.debug"
    def process = cmdString.execute()
    process.waitFor(10, TimeUnit.SECONDS)
    cmdString = "adb shell ls -al /sdcard/Download/.debug"
    process = cmdString.execute()
    process.waitFor(10, TimeUnit.SECONDS)
    printOutput(process)
}

def delDebugFile() {
    def cmdString = "adb shell rm /sdcard/Download/.debug"
    def process = cmdString.execute()
    process.waitFor(10, TimeUnit.SECONDS)
    cmdString = "adb shell ls -al /sdcard/Download/.debug"
    process = cmdString.execute()
    process.waitFor(10, TimeUnit.SECONDS)
    printOutput(process)
}

def getAaptFile() {
    def sdkDir = null
    try {
        Properties properties = new Properties()
        InputStream inputStream = project.rootProject.file('local.properties').newDataInputStream();
        properties.load(inputStream)
        //读取文件
        sdkDir = properties.getProperty('sdk.dir')
    } catch (Exception e) {
    }
    if (sdkDir == null || !new File(sdkDir).exists()) {
        if (sdkDir == null) {
            println ":${project.name}:getAaptFile sdkDir == null, Use ANDROID_SDK_ROOT"
        } else {
            println ":${project.name}:getAaptFile sdkDir is not exist, Use ANDROID_SDK_ROOT"
        }
        sdkDir = System.getenv("ANDROID_SDK_ROOT")
    }
    if (sdkDir == null || !new File(sdkDir).exists()) {
        if (sdkDir == null) {
            println ":${project.name}:getAaptFile sdkDir == null, Use ANDROID_HOME"
        } else {
            println ":${project.name}:getAaptFile sdkDir is not exist, Use ANDROID_HOME"
        }
        sdkDir = System.getenv("ANDROID_HOME")
    }
    // println "> Task :${project.name}:getAaptFile sdkDir : " + sdkDir
    if (sdkDir == null) {
        println "> Task :${project.name}:getAaptFile sdkDir == null"
        return null
    }
    if (!new File(sdkDir).exists()) {
        println "> Task :${project.name}:getAaptFile sdkDir is not exist"
        return null
    }
    def exe = ""
    if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        exe = ".exe"
    }
    def compileSdkVersion = android.compileSdkVersion
    if (compileSdkVersion != null) {
        compileSdkVersion = compileSdkVersion.replaceAll("android-", "");
    }
    def buildToolDir = sdkDir + File.separator + "build-tools"
    def buildToolVersionDir = android.buildToolsVersion
    if (buildToolVersionDir == null) {
        def buildToolDirs = new File(buildToolDir).list(new FilenameFilter() {
            @Override
            boolean accept(File dir, String name) {
                return name.startsWith(String.valueOf(compileSdkVersion))
            }
        })
        if (buildToolDirs != null && buildToolDirs.length > 0) {
            buildToolVersionDir = buildToolDirs[0]
        }
    }
    def aaptFile = buildToolDir + File.separator + buildToolVersionDir + File.separator + "aapt" + exe
    // println "> Task :${project.name}:getAaptFile aaptFile : " + aaptFile
    return aaptFile
}

def getSuffix() {
    return ".cfg"
}

def getSuffixJson() {
    return ".json"
}

def isWindows() {
    return org.gradle.internal.os.OperatingSystem.current().isWindows()
}

/**
 * 打开Release目录
 * @param flavor
 * @return
 */
def openReleaseDir(flavor) {
    if (!isWindows() || !ext.has("openRelease") || ext["openRelease"] != true) {
        return
    }
    try {
        def outputDir = String.format("outputs/apk/%srelease", ((flavor != null && flavor.trim().length() > 0) ? flavor + "/" : ""))
        def outputPath = new File(project.buildDir, outputDir)
        def cmd = "explorer.exe " + outputPath
        cmd.execute()
        println ":${project.name}:openReleaseDir [${outputPath}]"
    } catch (Exception e) {
    }
}

/**
 * 获取applicationId
 * @param flavor
 * @return
 */
def getApplicationId(flavor) {
    if (flavor == null || flavor.trim().length() == 0) {
        return project.android.defaultConfig.applicationId
    }
    def productFlavor = project.android.productFlavors[flavor]
    if (productFlavor.applicationId == null) {
        return project.android.defaultConfig.applicationId
    }
    return productFlavor.applicationId
}

def addToOutDirList(List assetsOutDirList, outAssetsDir) {
    if (assetsOutDirList != null && outAssetsDir != null) {
        def finalAssetsDir = new File(project.getBuildDir(), outAssetsDir)
        if (finalAssetsDir.exists()) {
            assetsOutDirList.add(finalAssetsDir)
        }
    }
}

/**
 * 获取assets输出目录
 * @param flavor
 * @return
 */
def getAssetsOutDir(flavor, appId) {
    def productFlavor = toUpperCaseFirstOne(flavor)
    def flavorNoSlash = productFlavor == null ? "" : productFlavor
    List<File> assetsOutDirList = []
    def outAssetsDir = null
    // 增加所有可能的Assets目录
    outAssetsDir = String.format("intermediates/assets/%s/release", flavorNoSlash)
    addToOutDirList(assetsOutDirList, outAssetsDir)

    outAssetsDir = String.format("intermediates/merged_assets/%srelease/merge%sReleaseAssets/out", flavorNoSlash, flavorNoSlash)
    addToOutDirList(assetsOutDirList, outAssetsDir)

    outAssetsDir = String.format("intermediates/assets/%srelease/merge%sReleaseAssets", flavorNoSlash, flavorNoSlash)
    addToOutDirList(assetsOutDirList, outAssetsDir)

    outAssetsDir = String.format("intermediates/merged_assets/%srelease/out", flavorNoSlash, flavorNoSlash)
    addToOutDirList(assetsOutDirList, outAssetsDir)

    outAssetsDir = String.format("intermediates/assets/%srelease", flavorNoSlash)
    addToOutDirList(assetsOutDirList, outAssetsDir)

    def adConfigList = getConfigNameList(appId)
    if (adConfigList != null && !adConfigList.isEmpty()) {
        List<File> mobSdkAssetsFiles = []
        def assetsFileName = ['assets', 'merged_assets']
        assetsFileName.forEach { assetsName ->
            FileTree mainTree = fileTree(dir: new File(project.getBuildDir(), "intermediates" + File.separator + assetsName))
            mainTree.each {
                if (it != null && adConfigList.contains(it.getName())) {
                    mobSdkAssetsFiles.add(it)
                }
            }
        }
        if (mobSdkAssetsFiles != null && !mobSdkAssetsFiles.isEmpty()) {
            assetsOutDirList.clear()
            mobSdkAssetsFiles.forEach {
                if (it != null && it.exists()) {
                    assetsOutDirList.add(it.parentFile)
                }
            }
        }
    }
    return assetsOutDirList
}

/**
 * 生成包名对应的广告配置文件名称
 * @param flavor
 * @return
 */
def adFileGenerateByUser(flavorName) {
    def appId = getApplicationId(flavorName)
    def pkgnameMd5 = Utils.string2MD5(appId)
    def adConfigName = "mob" + pkgnameMd5.substring(0, 8) + getSuffix()
    println "generateAdFileName : " + adConfigName
    println "generateOriginName : " + "app_mob_data.cfg"
}

def getConfigNameList(appId) {
    def pkgnameMd5 = Utils.string2MD5(appId)
    def adConfigNameList = ["mob" + pkgnameMd5.substring(0, 8), "app_mob_data"]
    def adSuffixNameList = [getSuffix(), getSuffixJson()]
    def adConfigNameWithSuffixList = []
    adConfigNameList.forEach { adName ->
        adSuffixNameList.forEach { suffix ->
            adConfigNameWithSuffixList.add(adName + suffix)
        }
    }
    return adConfigNameWithSuffixList
}
/**
 * 获取广告配置文件名称
 * @param assetsDirList
 * @param appId
 * @return
 */
def getAdConfigFile(List<File> assetsDirList, appId) {
    def pkgnameMd5 = Utils.string2MD5(appId)
    def adConfigNameList = ["mob" + pkgnameMd5.substring(0, 8), "app_mob_data"]
    def adSuffixNameList = [getSuffix(), getSuffixJson()]
    def adConfigFileList = [:]
    def adConfigFilePath = null
    if (assetsDirList != null && !assetsDirList.isEmpty()) {
        assetsDirList.forEach { assetDir ->
            adConfigNameList.forEach { adName ->
                adSuffixNameList.forEach { suffix ->
                    adConfigFilePath = new File(assetDir, adName + suffix)
                    if (adConfigFilePath.exists()) {
                        adConfigFileList.put(adConfigFilePath, assetDir.getAbsolutePath())
                    }
                }
            }
        }
    }
    return adConfigFileList
}

/**
 * 获取待加密的文件树
 * @param assetDir
 * @return
 */
def getEncryptFileTree(List assetDirList) {
    def encryptFilePathMap = null
    if (assetDirList != null && !assetDirList.isEmpty()) {
        List output = ext != null && ext.has("encryptFiles") ? ext.encryptFiles : null
        if (output != null && !output.isEmpty()) {
            encryptFilePathMap = [:]
            assetDirList.forEach { assetDir ->
                FileTree mainTree = fileTree(dir: assetDir)
                output.each { out ->
                    mainTree.include out
                }
                mainTree.each {
                    if (it.exists()) {
                        encryptFilePathMap.put(it, assetDir.getAbsolutePath())
                    }
                }
            }
        }
    }
    return encryptFilePathMap
}

/**
 * 获取签名信息
 * @param flavor
 * @return
 */
def getSignConfig(flavor) {
    def signConfig = null
    if (flavor == null) {
        try {
            signConfig = project.android.buildTypes.release.signingConfig
        } catch (Exception e) {
        }
    } else {
        try {
            signConfig = project.android.productFlavors[flavor].signingConfig
        } catch (Exception e) {
        }
    }
    if (signConfig == null) {
        try {
            signConfig = project.android.buildTypes.release.signingConfig
        } catch (Exception e) {
        }
    }
    return signConfig
}

/**
 * 生成签名的md5文件，一边验证是否被重打包
 * @param assetDir
 */
def generateSignMd5(flavor, assetDir) {
    def signConfig = getSignConfig(flavor)
    def signMd5 = null
    if (signConfig != null && signConfig.hasProperty("storeFile") && signConfig.hasProperty("storePassword")) {
        def cmdString = String.format("keytool -v -list -keystore %s -storepass %s", signConfig.storeFile, signConfig.storePassword)
        def result = cmdString.execute().text.trim()
        BufferedReader br = new BufferedReader(new StringReader(result))
        try {
            while ((line = br.readLine()) != null) {
                if (line.trim().startsWith("MD5:") || line.trim().startsWith("md5:")) {
                    signMd5 = line.trim().substring("MD5:".length()).trim()
                    break
                }
            }
        } catch (Exception e) {
        }
    }
    if (signMd5 != null && signMd5.trim().length() > 0) {
        signMd5 = signMd5.replaceAll(":", "")
        signMd5 = signMd5.toLowerCase()
    }
    println ":${project.name}:signMd5 [${signMd5}]"
    return null
}

/**
 * 加密asset文件
 * @param flavor
 * @return
 */
def encryptAssetsFiles(flavor) {
    println ""
    def secret = ext != null && ext.has("secret") ? ext["secret"] : "123456789"
    def useAesNew = ext != null && ext.has("aesNew") ? ext["aesNew"] : true
    def appId = getApplicationId(flavor)
    def assetDirList = getAssetsOutDir(flavor, appId)
    if (assetDirList == null || assetDirList.isEmpty()) {
        System.err.println("> Task :${project.name}:encryptAssetsFile [AssetDir Not Exist]");
        return
    }
    Global.sEncryptFileList.clear()
    // def signFile = generateSignMd5(flavor, assetDir)
    def adFileMap = getAdConfigFile(assetDirList, appId)
    if (adFileMap != null && !adFileMap.isEmpty()) {
        adFileMap.each { map ->
            File adFile = map.key
            def adFilePath = adFile.getAbsolutePath()
            def needEncrypt = Utils.isJson(adFilePath)
            def assetDir = map.value
            def fullFilePath = adFile.getAbsolutePath()
            def shortFilePath = fullFilePath.replace(assetDir, "")
            if (shortFilePath != null && shortFilePath.startsWith(File.separator)) {
                shortFilePath = shortFilePath.substring(1)
            }
            println "> Task :${project.name}:encryptAssetsFile [${shortFilePath}] need encrypt : $needEncrypt"
            if (needEncrypt) {
                try {
                    if (useAesNew) {
                        AesNew.encryptFile(adFilePath, secret)
                    } else {
                        Aes.encryptFile(adFilePath, secret)
                    }
                    Global.sEncryptFileList.add(assetDir)
                    Global.sEncryptFileList.add(shortFilePath)
                    println "> Task :${project.name}:encryptAssetsFile [$shortFilePath] encrypt successfully"
                } catch (Exception e) {
                    e.printStackTrace()
                }
            } else {
                println "> Task :${project.name}:encryptAssetsFile [$shortFilePath] has encrypted previously"
            }
        }
    } else {
        println "> Task :${project.name}:encryptAssetsFile [Ad Config File Not Exist]"
    }
    def mainTree = getEncryptFileTree(assetDirList)
    if (mainTree != null && !mainTree.isEmpty()) {
        mainTree.each { map ->
            def file = map.key
            def filePath = file.getAbsolutePath()
            def needEncrypt = Utils.isJson(filePath)
            def assetDir = map.value
            def fullFilePath = file.getAbsolutePath()
            String shortFilePath = fullFilePath.replace(assetDir, "")
            if (shortFilePath != null && shortFilePath.startsWith(File.separator)) {
                shortFilePath = shortFilePath.substring(1)
            }
            println "> Task :${project.name}:encryptAssetsFile [${shortFilePath}] need encrypt : $needEncrypt"
            if (needEncrypt) {
                try {
                    if (useAesNew) {
                        AesNew.encryptFile(filePath, secret)
                    } else {
                        Aes.encryptFile(filePath, secret)
                    }
                    Global.sEncryptFileList.add(assetDir)
                    Global.sEncryptFileList.add(shortFilePath)
                    println "> Task :app:encryptAssetsFile [${shortFilePath}] encrypt successfully"
                } catch (Exception e) {
                    e.printStackTrace()
                }
            } else {
                println "> Task :${project.name}:encryptAssetsFile [${shortFilePath}] has encrypted previously"
            }
        }
    }
}

/**
 * 使用 jarsigner 对 .aab 文件进行签名
 *
 * @param aabFilePath 要签名的 .aab 文件路径
 * @param keystorePath keystore 文件路径
 * @param storePassword keystore 密码
 * @param keyAlias key 的别名
 * @param keyPassword key 的密码（可与 keystore 密码相同）
 */
def signAabWithJarsigner(String aabFilePath, String keystorePath, String storePassword, String keyAlias, String keyPassword) {
    def jarsigner = new File("${System.getenv('JAVA_HOME') ?: 'java'}/bin/jarsigner").getCanonicalFile()
    println "> Task :${project.name}:signAabWithJarsigner jarsigner : $jarsigner"
    if (!new File(jarsigner).exists()) {
        throw new GradleException("签名失败:Jarsigner File is not exists")
    }
    def cmd = [
            jarsigner,
            "-verbose",
            "-sigalg", "SHA256withRSA",
            "-digestalg", "SHA-256",
            "-keystore", keystorePath,
            "-storepass", storePassword,
            "-keypass", keyPassword,
            aabFilePath,
            keyAlias
    ]

    println "> Task :${project.name}:signAabWithJarsigner 执行签名命令 : ${cmd.join(' ')}"
    def process = cmd.execute()
    def output = new StringBuffer()
    def error = new StringBuffer()
    process.consumeProcessOutput(output, error)
    process.waitFor()

    // println output.toString()
    if (process.exitValue() != 0) {
        throw new GradleException("签名失败:\n${error.toString()}")
    } else {
        println "> Task :${project.name}:signAabWithJarsigner ✅ 签名成功 : ${aabFilePath}"
    }
}


def removeBundleMetaData(flavor) {
    if (ext.has("removeBundleMetaData")) {
        List<String> bundleMetaData = ext.get("removeBundleMetaData")
        if (bundleMetaData == null || bundleMetaData.isEmpty()) {
            return
        }
        def flavorName = flavor != null ? flavor : ""
        def outputFile = null
        def outputDir = getBuildDir()
        outputDir = new File(outputDir, "outputs")
        outputDir = new File(outputDir, "bundle")
        if (flavor != null) {
            outputDir = new File(outputDir, flavorName + "Release")
        } else {
            outputDir = new File(outputDir, "release")
        }
        File[] outputFileList = outputDir.listFiles()
        if (outputFileList != null && outputFileList.length > 0) {
            outputFile = outputFileList[0]
        }
        println ""
        println "> Task :${project.name}:removeBundleMetaData [$flavor] flavorName : " + flavorName
        println "> Task :${project.name}:removeBundleMetaData [$flavor] outputDir : " + outputDir
        println "> Task :${project.name}:removeBundleMetaData [$flavor] outputFile : " + outputFile
        println "> Task :${project.name}:removeBundleMetaData [$flavor] outputFiles : " + outputDir.list()
        if (outputFile != null && outputFile.exists()) {
            def aaptFile = getAaptFile()
            if (aaptFile != null && new File(aaptFile).exists()) {
                println "> Task :${project.name}:removeBundleMetaData [$flavor] aapt file : $aaptFile"
                def cmdList = ["aapt", "r", outputFile.absolutePath]
                List<String> bundleFiles = listZipDirectoryEntries(outputFile.getAbsolutePath(), ["BUNDLE-METADATA/"])
                bundleFiles.forEach {
                    for (name in bundleMetaData) {
                        if (it.endsWith(name)) {
                            cmdList.add(it)
                        }
                    }
                }
                def cmdString = cmdList.join(" ")
                println "> Task :${project.name}:removeBundleMetaData [$flavor] execute remove bundle metadata cmd : " + cmdString
                def result = cmdList.execute().text
                println "> Task :${project.name}:removeBundleMetaData [$flavor] execute remove bundle metadata result : " + result
                def signConfig = getAab2ApkSignConfig(flavor)
                if (signConfig == null || !signConfig.containsKey("storeFile")
                        || !signConfig.containsKey("storePassword")
                        || !signConfig.containsKey("keyAlias")
                        || !signConfig.containsKey("keyPassword")) {
                    println "> Task :${project.name}:removeBundleMetaData [$flavor] signConfig is not completion"
                    return
                }
                def storeFile = signConfig.storeFile
                def storePassword = signConfig.storePassword
                def keyAlias = signConfig.keyAlias
                def keyPassword = signConfig.keyPassword
                signAabWithJarsigner(outputFile.absolutePath, storeFile.absolutePath, storePassword, keyAlias, keyPassword)
            }
        }
    }
}

def removeSpecialProguard(flavor) {
    def blackStringList = null
    if (ext != null && ext.has("proguardBlackString")) {
        blackStringList = ext["proguardBlackString"]
    }
    if (blackStringList != null && !blackStringList.isEmpty()) {
        println "> Task :${project.name}:removeSpecialProguard [$flavor]"
        def flavorName = flavor != null ? flavor : ""
        def mappingFile = null
        def mappingBack = null
        def mappingTemp = null
        def cleanedFile = null
        def outputDir = getBuildDir()
        outputDir = new File(outputDir, "outputs")
        outputDir = new File(outputDir, "mapping")
        if (flavor != null) {
            outputDir = new File(outputDir, flavorName + "Release")
        } else {
            outputDir = new File(outputDir, "release")
        }
        File[] outputFileList = outputDir.listFiles()
        if (outputFileList != null && outputFileList.length > 0) {
            mappingFile = new File(outputDir, "mapping.txt")
            mappingBack = new File(outputDir, "mapping-back.txt")
            mappingTemp = new File(outputDir, "mapping-cleaned-temp.txt")
            cleanedFile = new File(outputDir, "mapping-cleaned.txt")
        }
        println "> Task :${project.name}:removeSpecialProguard [$flavor] flavorName : " + flavorName
        println "> Task :${project.name}:removeSpecialProguard [$flavor] outputDir : " + outputDir
        println "> Task :${project.name}:removeSpecialProguard [$flavor] outputFile : " + mappingFile
        println "> Task :${project.name}:removeSpecialProguard [$flavor] outputFiles : " + outputDir.list()
        if (mappingFile != null && mappingFile.exists()) {
            println "> Task :${project.name}:removeSpecialProguard [$flavor] start processing $blackStringList"
            if (mappingBack != null) {
                if (mappingBack.exists()) {
                    mappingBack.delete()
                }
                Files.copy(mappingFile.toPath(), mappingBack.toPath())
            }
            def skip = false
            def cleanedCount = 0

            def reader = mappingFile.newReader()
            def writer = mappingTemp.newWriter()
            def resultWriter = cleanedFile.newWriter()
            try {
                reader.eachLine { line ->
                    if (line.endsWith(":")) {
                        skip = blackStringList.any { line.contains(it) }
                    }
                    if (!skip) {
                        writer.writeLine(line)
                    } else {
                        cleanedCount++
                        resultWriter.writeLine(line)
                    }
                }
            } finally {
                reader.close()
                writer.close()
                resultWriter.close()
            }

            mappingFile.delete()
            mappingTemp.renameTo(mappingFile)
            println "> Task :${project.name}:removeSpecialProguard [$flavor] process complete count [$cleanedCount]"
        }
    }
}

import java.util.zip.ZipFile
import java.util.zip.ZipEntry

/**
 * 列出 zip/aab 文件中指定目录数组下的所有非目录文件路径。
 *
 * @param zipPath zip 或 aab 文件路径
 * @param dirPrefixes 要列出的目录前缀数组，例如 ["BUNDLE-METADATA/", "base/"]
 * @return 包含所有匹配文件路径的 List<String>
 */
def listZipDirectoryEntries(String zipPath, List<String> dirPrefixes) {
    def entries = []

    ZipFile zipFile = new ZipFile(zipPath)
    zipFile.entries().each { ZipEntry entry ->
        if (!entry.isDirectory()) {
            for (prefix in dirPrefixes) {
                if (entry.name.startsWith(prefix)) {
                    entries << entry.name
                    break  // 找到匹配就跳出for，避免重复添加
                }
            }
        }
    }
    zipFile.close()
    return entries
}


def listBundleMetaDataFiles(flavor) {
    def flavorName = flavor != null ? flavor : ""
    def outputFile = null
    def outputDir = getBuildDir()
    outputDir = new File(outputDir, "outputs")
    outputDir = new File(outputDir, "bundle")
    if (flavor != null) {
        outputDir = new File(outputDir, flavorName + "Release")
    } else {
        outputDir = new File(outputDir, "release")
    }
    File[] outputFileList = outputDir.listFiles()
    if (outputFileList != null && outputFileList.length > 0) {
        outputFile = outputFileList[0]
    }
    println ""
    println "> Task :${project.name}:listBundleMetaDataFiles [$flavor] flavorName : " + flavorName
    println "> Task :${project.name}:listBundleMetaDataFiles [$flavor] outputDir : " + outputDir
    println "> Task :${project.name}:listBundleMetaDataFiles [$flavor] outputFile : " + outputFile
    println "> Task :${project.name}:listBundleMetaDataFiles [$flavor] outputFiles : " + outputDir.list()
    if (outputFile != null && outputFile.exists()) {
        def bundleFiles = listZipDirectoryEntries(outputFile.getAbsolutePath(), ["BUNDLE-METADATA/", "META-INF"])
        if (bundleFiles != null && !bundleFiles.isEmpty()) {
            println "> Task :${project.name}:listBundleMetaDataFiles [$flavor] >>>"
            bundleFiles.forEach {
                println "> Task :>>>> $it"
            }
            println "> Task :${project.name}:listBundleMetaDataFiles [$flavor] <<<"
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////
afterEvaluate {
    try {
        def taskName = getGradle().getStartParameter().getTaskRequests()[0]["args"][0].toString()
        if (taskName != null && taskName.toLowerCase(Locale.ENGLISH).contains("bundle")) {
            def index = taskName.lastIndexOf(":")
            if (index > -1) {
                taskName = taskName.substring(index + 1)
            }
            def aTask = project.tasks.findByName(taskName)
            if (aTask != null) {
                aTask.doLast {
                    if (Global.sEncryptFileList != null && !Global.sEncryptFileList.isEmpty()) {
                        println ""
                        println "> Task :${project.name}:encryptAssetsFile [assets files encrypted result]"
                        Global.sEncryptFileList.forEach {
                            println "> Task :${project.name}:encryptAssetsFile [$it]"
                        }
                        println ""
                    }
                    if (isAAB2ApkAllow()) {
                        transformAab2ApkFlavor()
                    } else {
                        println "> Task :${project.name}:transformAab2Apk aab2apk is not set"
                    }
                    openBundleReleaseDir(taskName)
                }
            }
        }
    } catch (Exception e) {
    }
}


def openBundleReleaseDir(String taskName) {
    if (!ext.has("openRelease") || ext["openRelease"] != true) {
        return
    }
    if (isContainBundleRelease(taskName)) {
        try {
            def openCmd = org.gradle.internal.os.OperatingSystem.current().isWindows() ? "explorer.exe" : "open"
            def outputPath = new File(project.buildDir, "outputs/bundle")
            def outputReleasePath = new File(outputPath, "release")
            if (outputReleasePath.exists()) {
                outputPath = outputReleasePath
            }
            def cmd = openCmd + " " + outputPath
            cmd.execute()
            println ""
            println "> Task :${project.name}:openBundleDir [${outputPath}]"
        } catch (Exception e) {
        }
    }
}

def isContainBundleRelease(String taskName) {
    if (taskName != null && taskName.contains("Release")) {
        return true;
    }
    return false;
}

def isAAB2ApkAllow() {
    def aab2apk = true
    if (ext.has("aab2apk")) {
        aab2apk = ext.get("aab2apk")
    }
    return aab2apk
}

def getChannelList() {
    def channel_list = null
    if (ext.has("channels")) {
        channel_list = ext.get("channels")
    }
    return channel_list
}

def getChannelFileName() {
    def channelFileName = null
    if (ext.has("channelFileName")) {
        channelFileName = ext.get("channelFileName")
    }
    return channelFileName
}

def transformAab2ApkFlavor() {
    println ""
    println "> Task :${project.name}:transformAab2Apk"
    if (project.android.productFlavors.size() > 0) {// 如果有产品风味
        project.android.productFlavors.each { flavor ->
            def baseName = getArchivesBaseName()
            def aabOutputAabFileName = baseName + "-" + flavor.name + "-release.aab"
            transformAab2ApkLocked(flavor.name, aabOutputAabFileName)
        }
    } else {
        def baseName = getArchivesBaseName()
        def aabOutputAabFileName = baseName + "-release.aab"
        transformAab2ApkLocked(null, aabOutputAabFileName)
    }
}

def transformAab2ApkLocked(productFlavor, aabOutputFileName) {
    def flavorName = toUpperCaseFirstOne(productFlavor)
    println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] aabOutputFileName : " + aabOutputFileName
    if (aabOutputFileName != null) {
        aabOutputFileName = aabOutputFileName.replace(".apk", ".aab")
    }

    def obfuscatedBundleFileName = null
    try {
        obfuscatedBundleFileName = aabResGuard.obfuscatedBundleFileName
    } catch (Exception e) {
    }

    def finalBundleName = null
    if (obfuscatedBundleFileName != null && !obfuscatedBundleFileName.trim().isEmpty()) {
        finalBundleName = obfuscatedBundleFileName
    } else {
        finalBundleName = aabOutputFileName
    }
    def outputAabFile = null
    def buildDir = getBuildDir()
    if (flavorName != null && !flavorName.trim().isEmpty()) {
        outputAabFile = new File(buildDir, "outputs" + File.separatorChar + "bundle" + File.separatorChar + flavorName + "Release" + File.separatorChar + finalBundleName)
    } else {
        outputAabFile = new File(buildDir, "outputs" + File.separatorChar + "bundle" + File.separatorChar + "release" + File.separatorChar + finalBundleName)
    }
    def finalBundleFile = outputAabFile
    println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] finalBundleFile : " + finalBundleFile
    if (finalBundleFile == null || !finalBundleFile.exists()) {
        println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] finalBundleFile is not exist ###"
        return
    }
    def signConfig = getAab2ApkSignConfig(productFlavor)
    println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] signConfig : ${signConfig}"
    if (signConfig == null) {
        System.err.println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] signConfig is Null"
        return
    }
    if (!signConfig.containsKey("storeFile")
            || !signConfig.containsKey("storePassword")
            || !signConfig.containsKey("keyAlias")
            || !signConfig.containsKey("keyPassword")) {
        System.err.println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] signConfig is not completion"
        return
    }
    def bundleFileName = "bundletool-all-1.16.0.jar"
    def bundleToolDir = new File(gradle.gradleUserHomeDir, "bundletool")
    bundleToolDir.mkdirs()
    def bundleToolPath = new File(bundleToolDir, bundleFileName).getAbsolutePath()
    def bundleToolPathCompleteFile = new File(bundleToolDir, bundleFileName + ".lock").getAbsolutePath()
    println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] bundleToolPath : " + bundleToolPath
    if (!new File(bundleToolPath).exists() || !new File(bundleToolPathCompleteFile).exists()) {
        println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] Downloading " + bundleFileName
        def bundleToolUrl = "https://maven-release.bitbucket.io/release/com/argon/tools/bundletool/" + bundleFileName
        try {
            downloadFile(bundleToolUrl, bundleToolPath, "> Task :${project.name}:transformAab2Apk [" + flavorName + "] " + bundleFileName)
            new File(bundleToolPathCompleteFile).createNewFile()
        } catch (Exception e) {
            println "\n> Task :${project.name}:transformAab2Apk [" + flavorName + "] download file error"
            def bundleToolFile = new File(bundleToolPath)
            if (bundleToolFile.exists()) {
                bundleToolFile.delete()
            }
        }
    }

    if (bundleToolPath == null || !new File(bundleToolPath).exists()) {
        System.err.println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] bundle tool is null"
        return
    }
    executeTransformAab2Apk(signConfig, finalBundleFile, bundleToolPath, flavorName)

    def channelList = getChannelList()
    if (channelList != null && !channelList.isEmpty()) {
        channelList.each {
            def channel = it
            def fileDir = finalBundleFile.getParentFile()
            def finalBundleFileName = finalBundleFile.getName()
            def baseName = finalBundleFileName.substring(0, finalBundleFileName.lastIndexOf("."))
            def channelFileName = baseName + "_" + channel + ".aab"
            def channelAabFile = new File(fileDir, channelFileName)
            println ""
            println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] Generate Channel Apk : [" + channel + "]"
            copyFile(finalBundleFile.getAbsolutePath(), channelAabFile.getAbsolutePath())
            appendChannelToAabFile(channelAabFile.getAbsolutePath(), channel, fileDir, flavorName, getChannelFileName())
            executeTransformAab2Apk(signConfig, channelAabFile, bundleToolPath, flavorName)
            channelAabFile.delete()
        }
    }
}

def executeTransformAab2Apk(signConfig, finalBundleFile, bundleToolPath, flavorName) {
    def storeFile = signConfig.storeFile
    def storePassword = signConfig.storePassword
    def keyAlias = signConfig.keyAlias
    def keyPassword = signConfig.keyPassword
    def finalBundleFileName = finalBundleFile.getName()
    def finalApkFileName = finalBundleFileName.substring(0, finalBundleFileName.lastIndexOf(".aab"))
    def finalApksFile = new File(finalBundleFile.getParent(), finalApkFileName + ".apks")
    def finalApkFile = new File(finalBundleFile.getParent(), finalApkFileName + ".apk")
    def cmdList = ["java", "-jar", bundleToolPath,
                   "build-apks",
                   "--bundle=" + finalBundleFile,
                   "--output=" + finalApksFile,
                   "--overwrite", "--verbose",
                   "--ks=" + storeFile,
                   "--ks-pass=pass:" + storePassword,
                   "--ks-key-alias=" + keyAlias,
                   "--key-pass=pass:" + keyPassword,
                   "--mode=universal"]
    def cmdString = cmdList.join(" ")
    println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] Command : [" + optimizeCommand(cmdString) + "]"
    try {
        def process = cmdString.execute()
        def pid = process.waitFor()
        if (pid == 0) {
            println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] Result : [" + process.text.trim() + "]"
        } else {
            println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] Error  : [" + process.err.text + "]"
        }
        if (finalApksFile != null && finalApksFile.exists()) {
            extractFileFromZip(finalApksFile, "universal.apk", finalApkFile)
            println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] finalApkFile : [" + finalApkFile + "]"
            println ""
            if (finalApkFile.exists()) {
                finalApksFile.delete()
            }
        } else {
            println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] transform aab to apk failed"
            println ""
        }
    } catch (Exception e) {
        println "> Task :${project.name}:transformAab2Apk [" + flavorName + "] error : " + e
        println ""
    }
}

def copyFile(srcFile, dstFile) {
    File channelApkFile = new File(dstFile)
    if (channelApkFile.exists()) {
        channelApkFile.delete()
    }
    Files.copy(Paths.get(srcFile), Paths.get(dstFile))
}

def appendChannelToAabFile(aabFilePath, channel, releaseDir, flavorName, channelFileName) {
    println "> Task :${project.name}:appendChannelsFile [" + flavorName + "][" + channel + "] >>>>>>>>> Append Channels File Start <<<<<<<<<"
    println "> Task :${project.name}:appendChannelsFile [" + flavorName + "][" + channel + "] BaseApk [" + aabFilePath + "]"

    // 创建渠道文件
    File tempBase = new File(releaseDir, "base")
    tempBase.mkdirs()
    File tempAssets = new File(tempBase, "assets")
    tempAssets.mkdirs()
    if (channelFileName == null) {
        channelFileName = "ss_channel_cfg"
    }
    File channelFile = new File(tempAssets, channelFileName)

    // 给渠道文件写入渠道号
    FileWriter writer = new FileWriter(channelFile, false)
    writer.write(channel)
    writer.close()

    // 添加渠道文件到assets目录
    def cwd = new File(aabFilePath).getParent()
    appendFilesIntoApk(cwd, aabFilePath, ["base/assets/" + channelFileName])
    // 删除临时渠道文件
    channelFile.delete()
    tempAssets.delete()
    tempBase.delete()
    println "> Task :${project.name}:appendChannelsFile [" + flavorName + "][" + channel + "] >>>>>>>>> Append Channels File Complete <<<<<<<<<\n"
}

def getAppendCmdListByAapt(packageFile, aaptFile, fileList) {
    def cmd = []
    cmd.add(aaptFile)
    cmd.add("a")
    cmd.add("-v")
    cmd.add(packageFile)
    fileList.each {
        cmd.add(it)
    }
    return cmd
}

def appendFilesIntoApk(workDir, packageFile, fileList) {
    def aaptFile = getAaptFile()
    def cmd = getAppendCmdListByAapt(packageFile, aaptFile, fileList)
    if (cmd == null || cmd.isEmpty()) {
        println "> Task :${project.name}:appendFilesIntoApk Error [cmd is empty]"
        return
    }
    def cmdString = cmd.join(" ")
    println "> Task :${project.name}:appendFilesIntoApk Command [" + optimizeCommand(cmdString) + "]"
    try {
        Process p = cmdString.execute(null, new File(workDir))
        p.waitFor(20, TimeUnit.SECONDS)
        p.closeStreams()
        p.destroy();
    } catch (Exception e) {
        e.printStackTrace()
    }
}

def downloadFile(srcUrl, outputFilePath, progressText) {
    if (new File(outputFilePath).exists()) {
        new File(outputFilePath).delete()
    }
    def url = new URL(srcUrl)
    def connection = url.openConnection()
    def fileSize = connection.contentLength
    def inputStream = connection.inputStream
    def outputStream = new FileOutputStream(outputFilePath)
    byte[] buffer = new byte[4096]
    int bytesRead
    long totalBytesRead = 0
    try {
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            outputStream.write(buffer, 0, bytesRead)
            totalBytesRead += bytesRead
            if (fileSize > 0) {
                def progress = (totalBytesRead * 100 / fileSize) as int
                System.out.print("\r\033[K" + progressText + " Downloading... [$totalBytesRead/$fileSize] $progress% complete")
            } else {
                System.out.print("\r\033[K" + progressText + " Downloading... $totalBytesRead complete")
            }
            System.out.flush()
        }
    } catch (Exception e) {
        throw e
    } finally {
        try {
            inputStream.close()
            outputStream.close()
        } catch (Exception error) {
        }
    }
    println("\n" + progressText + " Download complete!")
}

def extractFileFromZip(packageFile, filePath, outputFile) {
    def extraSuccess = false
    try {
        ZipFile zipFile = new ZipFile(packageFile)
        ZipEntry zipEntry = zipFile.getEntry(filePath)
        if (zipEntry != null) {
            InputStream is = zipFile.getInputStream(zipEntry)
            byte[] buf = new byte[1024]
            def length = 0
            FileOutputStream fos = new FileOutputStream(outputFile)
            while ((length = is.read(buf)) > 0) {
                fos.write(buf, 0, length)
            }
            is.close()
            fos.close()
        }
        zipFile.close()
        extraSuccess = true
    } catch (Exception e) {
        extraSuccess = false
        e.printStackTrace()
    }
    return extraSuccess
}

def optimizeCommand(cmdString, delimiter = " ") {
    if (android.defaultConfig.ext.has("debug") && android.defaultConfig.ext["debug"]) {
        if (" ".equals(delimiter)) {
            return cmdString
        }
        return cmdString.replaceAll(",", " ")
    }
    try {
        List<String> list = Arrays.asList(cmdString.split(delimiter))
        List<String> list2 = new ArrayList<String>(list.size())
        for (int index = 0; index < list.size(); index++) {
            String s = list.get(index)
            File file = new File(s)
            if (file.exists()) {
                list2.add(file.getName())
            } else {
                list2.add(s)
            }
        }
        return list2.join(" ")
    } catch (Exception e) {
        e.printStackTrace()
    }
    return cmdString
}

/**
 * 获取签名信息
 * @param flavor
 * @return
 */
def getAab2ApkSignConfig(flavor) {
    if (ext.has("signingConfig")) {
        signingConfig = ext.get("signingConfig")
        if (signingConfig != null
                && signingConfig.containsKey("keyAlias")
                && signingConfig.containsKey("keyPassword")
                && signingConfig.containsKey("storeFile")
                && signingConfig.containsKey("storePassword")) {
            return signingConfig
        }
    }
    def signConfig = getReleaseSignConfig(flavor)
    if (signConfig != null && signConfig.hasProperty("storeFile")
            && signConfig.hasProperty("storePassword")
            && signConfig.hasProperty("keyAlias")
            && signConfig.hasProperty("keyPassword")) {
        return [
                storeFile    : signConfig.storeFile,
                storePassword: signConfig.storePassword,
                keyAlias     : signConfig.keyAlias,
                keyPassword  : signConfig.keyPassword
        ]
    }
    return null
}

def getReleaseSignConfig(flavor) {
    def signConfig = null
    if (flavor == null) {
        try {
            signConfig = project.android.buildTypes.release.signingConfig
        } catch (Exception e) {
            System.err.println(e)
        }
    } else {
        try {
            signConfig = project.android.productFlavors[flavor].signingConfig
        } catch (Exception e) {
            System.err.println(e)
        }
    }
    if (signConfig == null) {
        try {
            signConfig = project.android.buildTypes.release.signingConfig
        } catch (Exception e) {
            System.err.println(e)
        }
    }
    return signConfig
}
//////////////////////////////////////////////////////////////////////////////////////////
def newEncryptStringTask() {
    println "【新加密】请输入密钥和内容（回车）: "
    def reader = new BufferedReader(new InputStreamReader(System.in))
    def key = reader.readLine()
    def input = reader.readLine()
    println "[$key][$input]"
    String output = AesNew.encryptPublic(key, input)
    println "加密结果: [$output]"
}

def newDecryptStringTask() {
    println "【新加密】请输入密钥和内容（回车）: "
    def reader = new BufferedReader(new InputStreamReader(System.in))
    def key = reader.readLine()
    def input = reader.readLine()
    println "[$key][$input]"
    String output = AesNew.decrypt(key, input)
    println "解密结果: [$output]"
}
def oldEncryptStringTask() {
    println "【旧加密】请输入密钥和内容（回车）: "
    def reader = new BufferedReader(new InputStreamReader(System.in))
    def key = reader.readLine()
    def input = reader.readLine()
    println "[$key][$input]"
    String output = Aes.encryptPublic(key, input)
    println "加密结果: [$output]"
}

def oldDecryptStringTask() {
    println "【旧加密】请输入密钥和内容（回车）: "
    def reader = new BufferedReader(new InputStreamReader(System.in))
    def key = reader.readLine()
    def input = reader.readLine()
    println "[$key][$input]"
    String output = Aes.decrypt(key, input)
    println "解密结果: [$output]"
}
//////////////////////////////////////////////////////////////////////////////////////////
class Aes {
    private static void appendHex(StringBuffer paramStringBuffer, byte paramByte) {
        paramStringBuffer.append(
                "0123456789ABCDEF".charAt(0xF & paramByte >> 4)).append(
                "0123456789ABCDEF".charAt(paramByte & 0xF));
    }

    static String decrypt(String key, String content) {
        try {
            String str = new String(decrypt(getRawKey(key.getBytes()),
                    toByte(content)));
            return str;
        } catch (Exception localException) {
            System.out.println("decrypt error: " + localException);
        }
        return null;
    }

    static byte[] decrypt(byte[] key,
                          byte[] content) throws Exception {
        SecretKeySpec localSecretKeySpec = new SecretKeySpec(key,
                "AES");
        Cipher localCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        localCipher.init(2, localSecretKeySpec, new IvParameterSpec(
                new byte[localCipher.getBlockSize()]));
        return localCipher.doFinal(content);
    }

    static String decryptRaw(String seed, byte[] content) {
        try {
            String str = new String(
                    decrypt(getRawKey(seed.getBytes()), content));
            return str;
        } catch (Exception localException) {
            System.out.println("decrypt raw error: " + localException);
        }
        return null;
    }

    static String encryptPublic(String key, String content) {
        try {
            byte[] result = encrypt(getRawKey(key.getBytes()),
                    content.getBytes());
            return toHex(result);
        } catch (Exception localException) {
        }
        return null;
    }

    private static byte[] encrypt(byte[] key,
                                  byte[] content) throws Exception {
        SecretKeySpec localSecretKeySpec = new SecretKeySpec(key,
                "AES");
        Cipher localCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        localCipher.init(1, localSecretKeySpec, new IvParameterSpec(
                new byte[localCipher.getBlockSize()]));
        return localCipher.doFinal(content);
    }

    static byte[] encryptRaw(String key, String content) {
        try {
            byte[] arrayOfByte = encrypt(getRawKey(key.getBytes()),
                    content.getBytes());
            return arrayOfByte;
        } catch (Exception localException) {
            System.out.println("encrypt raw error: " + localException);
        }
        return null;
    }

    static String fromHex(String content) {
        return new String(toByte(content));
    }

    private static byte[] getRawKey(byte[] key) throws Exception {
        byte[] arrayOfByte = new byte[16];
        if (key == null)
            throw new IllegalArgumentException("seed == null");
        if (key.length == 0)
            throw new IllegalArgumentException("seed.length == 0");
        if (key.length < 16) {
            int i = 0;
            while (i < arrayOfByte.length) {
                if (i < key.length) {
                    arrayOfByte[i] = key[i];
                } else {
                    arrayOfByte[i] = 0;
                }
                i++;
            }
        }
        return arrayOfByte;
    }

    static byte[] toByte(String content) {
        int i = content.length() / 2;
        byte[] arrayOfByte = new byte[i];
        for (int j = 0; j < i; j++)
            arrayOfByte[j] = Integer.valueOf(
                    content.substring(j * 2, 2 + j * 2), 16).byteValue();
        return arrayOfByte;
    }

    static String toHex(String content) {
        return toHex(content.getBytes());
    }

    static String toHex(byte[] content) {
        if (content == null)
            return "";
        StringBuffer localStringBuffer = new StringBuffer(
                2 * content.length);
        for (int i = 0; i < content.length; i++)
            appendHex(localStringBuffer, content[i]);
        return localStringBuffer.toString();
    }

    private static String readFromFile(File f) {
        if (!f.exists()) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        try {
            byte[] buf = new byte[4096];
            int read = 0;
            FileInputStream fis = new FileInputStream(f);
            while ((read = fis.read(buf)) > 0) {
                builder.append(new String(buf, 0, read));
            }
            fis.close();
            return builder.toString();
        } catch (Exception e) {
        }
        return null;
    }

    private static void writeToFile(File f, String out) {
        try {
            if (f.exists()) {
                f.delete();
            }
            f.createNewFile();
            FileOutputStream fos = new FileOutputStream(f);
            fos.write(out.getBytes());
            fos.close();
        } catch (Exception e) {
        }
    }

    private static void usage() {
        String usage = "java -jar aes.jar <-k rawkey> [-e/-d] [-i input] [-o output] [-s str]";
        System.out.println(usage);
    }

    private static boolean isEmpty(String str) {
        if (str == null || str.trim().equals("")) {
            return true;
        }
        return false;
    }

    static void encryptFile(String originFile, String secret) {
        try {
            String encrypt = encryptPublic(secret, readFromFile(new File(originFile))); //加密
            writeToFile(new File(originFile), encrypt);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

class AesNew {
    private static final int IV_SIZE = 12; // GCM 推荐长度
    private static final int TAG_LENGTH = 128;
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final String ALGORITHM = "AES";

    private static void appendHex(StringBuffer paramStringBuffer, byte paramByte) {
        paramStringBuffer.append("0123456789ABCDEF".charAt(0xF & paramByte >> 4))
                .append("0123456789ABCDEF".charAt(paramByte & 0xF));
    }

    public static String decrypt(String key, String content) {
        try {
            return new String(decrypt(getRawKey(key.getBytes(StandardCharsets.UTF_8)), toByte(content)));
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static byte[] decrypt(byte[] key, byte[] content) throws Exception {
        ByteBuffer buffer = ByteBuffer.wrap(content);
        byte[] iv = new byte[IV_SIZE];
        buffer.get(iv);
        byte[] cipherText = new byte[buffer.remaining()];
        buffer.get(cipherText);

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        SecretKeySpec keySpec = new SecretKeySpec(key, ALGORITHM);
        GCMParameterSpec spec = new GCMParameterSpec(TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, keySpec, spec);
        return cipher.doFinal(cipherText);
    }

    public static String decryptRaw(String key, byte[] content) {
        try {
            return new String(decrypt(getRawKey(key.getBytes(StandardCharsets.UTF_8)), content));
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    static String encrypt(String key, String content) {
        try {
            byte[] result = encrypt(getRawKey(key.getBytes(StandardCharsets.UTF_8)), content.getBytes(StandardCharsets.UTF_8));
            return toHex(result);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    static byte[] encrypt(byte[] key, byte[] content) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        byte[] iv = new byte[IV_SIZE];
        new SecureRandom().nextBytes(iv);

        SecretKeySpec keySpec = new SecretKeySpec(key, ALGORITHM);
        GCMParameterSpec spec = new GCMParameterSpec(TAG_LENGTH, iv);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);

        byte[] cipherText = cipher.doFinal(content);

        ByteBuffer buffer = ByteBuffer.allocate(iv.length + cipherText.length);
        buffer.put(iv);
        buffer.put(cipherText);
        return buffer.array();
    }

    public static byte[] encryptRaw(String key, String content) {
        try {
            return encrypt(getRawKey(key.getBytes(StandardCharsets.UTF_8)), content.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String fromHex(String content) {
        return new String(toByte(content));
    }

    private static byte[] getRawKey(byte[] key) {
        byte[] keyByte = new byte[16];
        for (int i = 0; i < keyByte.length; i++) {
            keyByte[i] = (i < key.length) ? key[i] : 0;
        }
        return keyByte;
    }

    public static byte[] toByte(String content) {
        int len = content.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++) {
            result[i] = (byte) Integer.parseInt(content.substring(i * 2, i * 2 + 2), 16);
        }
        return result;
    }

    public static String toHex(String content) {
        return toHex(content.getBytes(StandardCharsets.UTF_8));
    }

    public static String toHex(byte[] content) {
        if (content == null) return "";
        StringBuffer sb = new StringBuffer(2 * content.length);
        for (byte b : content) appendHex(sb, b);
        return sb.toString();
    }

    public static void aesEncryptFile(String sourceFile, String encryptFile, byte[] password) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        byte[] iv = new byte[IV_SIZE];
        new SecureRandom().nextBytes(iv);
        SecretKeySpec keySpec = new SecretKeySpec(password, ALGORITHM);
        GCMParameterSpec spec = new GCMParameterSpec(TAG_LENGTH, iv);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, spec);

        try (FileInputStream inputStream = new FileInputStream(sourceFile);
             FileOutputStream outputStream = new FileOutputStream(encryptFile)) {
            outputStream.write(iv);
            try (CipherOutputStream cos = new CipherOutputStream(outputStream, cipher)) {
                byte[] buffer = new byte[1024];
                int len;
                while ((len = inputStream.read(buffer)) != -1) {
                    cos.write(buffer, 0, len);
                }
            }
        }
    }

    public static void aesDecryptFile(String encryptFile, String decryptFile, byte[] password) throws Exception {
        try (FileInputStream fis = new FileInputStream(encryptFile)) {
            byte[] iv = new byte[IV_SIZE];
            fis.read(iv);

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            SecretKeySpec keySpec = new SecretKeySpec(password, ALGORITHM);
            GCMParameterSpec spec = new GCMParameterSpec(TAG_LENGTH, iv);
            cipher.init(Cipher.DECRYPT_MODE, keySpec, spec);

            try (FileOutputStream fos = new FileOutputStream(decryptFile);
                 CipherInputStream cis = new CipherInputStream(fis, cipher)) {
                byte[] buffer = new byte[1024];
                int len;
                while ((len = cis.read(buffer)) != -1) {
                    fos.write(buffer, 0, len);
                }
            }
        }
    }

    private static void usage() {
        System.out.println("Usage: java -jar aes.jar <-k key> [-e|-d] [-b] [-i input] [-o output] [-s str]");
    }

    private static boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }

    private static void encryptOrDecryptString(String originString, boolean encrypt, String key) {
        String outputString = encrypt ? encrypt(key, originString) : decrypt(key, originString);
        System.out.println(outputString);
    }

    private static void encryptOrDecryptStringFile(String inputFile, String outputFile, boolean encrypt, String key) {
        try {
            String originString = readFromFile(new File(inputFile));
            if (isEmpty(originString)) {
                System.out.println("[error] Unable to read input file");
                return;
            }
            String outputString = encrypt ? encrypt(key, originString) : decrypt(key, originString);
            if (!isEmpty(outputFile)) {
                writeToFile(new File(outputFile), outputString);
            } else {
                System.out.println(outputString);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void encryptOrDecryptBinaryFile(String inputFile, String outputFile, boolean encrypt, String key) {
        try {
            if (encrypt) {
                aesEncryptFile(inputFile, outputFile, getRawKey(key.getBytes(StandardCharsets.UTF_8)));
            } else {
                aesDecryptFile(inputFile, outputFile, getRawKey(key.getBytes(StandardCharsets.UTF_8)));
            }
        } catch (Exception e) {
            System.out.println("[error] Failed binary file processing: " + e);
        }
    }

    public static void main(String[] args) {
        String key = null, input = null, output = null, inputstr = null;
        boolean encrypt = true, useBinary = false;
        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "-k":
                    key = args[++i];
                    break;
                case "-i":
                    input = args[++i];
                    break;
                case "-o":
                    output = args[++i];
                    break;
                case "-e":
                    encrypt = true;
                    break;
                case "-d":
                    encrypt = false;
                    break;
                case "-s":
                    inputstr = args[++i];
                    break;
                case "-b":
                    useBinary = true;
                    break;
            }
        }
        if (isEmpty(key)) {
            usage();
            return;
        }
        if (!isEmpty(inputstr)) {
            encryptOrDecryptString(inputstr, encrypt, key);
        } else if (useBinary) {
            encryptOrDecryptBinaryFile(input, output, encrypt, key);
        } else {
            encryptOrDecryptStringFile(input, output, encrypt, key);
        }
    }

    private static String readFromFile(File f) {
        if (!f.exists()) return null;
        try (FileInputStream fis = new FileInputStream(f)) {
            byte[] buf = new byte[4096];
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int read;
            while ((read = fis.read(buf)) > 0) {
                baos.write(buf, 0, read);
            }
            return baos.toString();
        } catch (Exception e) {
            return null;
        }
    }

    private static void writeToFile(File f, String out) {
        try (FileOutputStream fos = new FileOutputStream(f)) {
            fos.write(out.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String encryptPublic(String key, String content) {
        try {
            byte[] result = encrypt(getRawKey(key.getBytes()),
                    content.getBytes());
            return toHex(result);
        } catch (Exception localException) {
        }
        return null;
    }

    public static void encryptFile(String originFile, String secret) {
        try {
            String encrypt = encryptPublic(secret, readFromFile(new File(originFile))); //加密
            writeToFile(new File(originFile), encrypt);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class Utils {
    static String readFromStream(InputStream is) {
        if (is == null) {
            return null;
        }
        try {
            StringBuilder builder = new StringBuilder();
            int read = 0;
            byte[] buf = new byte[1024];
            while ((read = is.read(buf)) > 0) {
                builder.append(new String(buf, 0, read));
            }
            is.close();
            return builder.toString();
        } catch (Exception e) {
            e.printStackTrace()
        }
        return null;
    }

    static String readLocal(String filePath) {
        try {
            InputStream is = new FileInputStream(filePath);
            return readFromStream(is);
        } catch (Exception e) {
        }
        return null;
    }

    static boolean isJson(String file) {
        try {
            String s = readLocal(file)
            if (s != null) {
                s = s.trim()
            }
            if (s.startsWith("[") || s.startsWith("{")) {
                return true
            }
        } catch (Exception e) {
            e.printStackTrace()
        }
        return false
    }

    static String byte2MD5(byte[] byteArray) {
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
        byte[] md5Bytes = md5.digest(byteArray);
        StringBuffer hexValue = new StringBuffer();
        for (int i = 0; i < md5Bytes.length; i++) {
            int val = md5Bytes[i] & 0xff;
            if (val < 16) {
                hexValue.append("0");
            }
            hexValue.append(Integer.toHexString(val));
        }
        return hexValue.toString();
    }

    static String string2MD5(String source) {
        return string2MD5(source, "utf-8");
    }

    static String string2MD5(String source, String encode) {
        try {
            return byte2MD5(source.getBytes(encode));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "";
    }
}